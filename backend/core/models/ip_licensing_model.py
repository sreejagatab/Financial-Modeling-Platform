"""
IP Licensing Financial Model

Analyzes intellectual property licensing transactions including:
- Patent licensing
- Trademark/brand licensing
- Technology licensing
- Content/media licensing
- Royalty structures and valuation
"""

from dataclasses import dataclass, field
from typing import List, Dict, Any, Optional
from enum import Enum

from core.engine.base_model import BaseFinancialModel, CalculationResult


class IPType(str, Enum):
    """Types of intellectual property."""
    PATENT = "patent"
    TRADEMARK = "trademark"
    COPYRIGHT = "copyright"
    TRADE_SECRET = "trade_secret"
    TECHNOLOGY = "technology"
    BRAND = "brand"
    SOFTWARE = "software"
    CONTENT = "content"


class LicenseType(str, Enum):
    """Types of license agreements."""
    EXCLUSIVE = "exclusive"  # Only licensee can use
    NON_EXCLUSIVE = "non_exclusive"  # Multiple licensees
    SOLE = "sole"  # Only licensee and licensor can use
    FIELD_OF_USE = "field_of_use"  # Limited to specific field
    TERRITORY = "territory"  # Limited to geographic area


class RoyaltyStructure(str, Enum):
    """Royalty payment structures."""
    PERCENT_OF_SALES = "percent_of_sales"
    PERCENT_OF_PROFITS = "percent_of_profits"
    PER_UNIT = "per_unit"
    FLAT_FEE = "flat_fee"
    TIERED = "tiered"  # Different rates at different volumes
    HYBRID = "hybrid"  # Combination of structures


@dataclass
class IPAsset:
    """Intellectual property asset being licensed."""
    name: str
    ip_type: IPType
    description: str = ""
    remaining_life_years: int = 15
    current_annual_revenue: float = 0  # Revenue generated by IP
    cost_basis: float = 0  # Original development cost
    book_value: float = 0
    market_comparable_value: float = 0  # Based on comparable transactions


@dataclass
class RoyaltyTier:
    """Tiered royalty rate structure."""
    threshold: float  # Revenue/unit threshold
    rate: float  # Royalty rate above threshold


@dataclass
class IPLicensingInputs:
    """Inputs for IP licensing analysis."""
    # IP assets
    ip_assets: List[IPAsset] = field(default_factory=list)

    # Simplified inputs
    ip_type: IPType = IPType.PATENT
    ip_name: str = ""
    remaining_life_years: int = 15

    # License terms
    license_type: LicenseType = LicenseType.NON_EXCLUSIVE
    license_term_years: int = 10
    territory: str = "worldwide"
    field_of_use: str = ""

    # Royalty structure
    royalty_structure: RoyaltyStructure = RoyaltyStructure.PERCENT_OF_SALES
    royalty_rate: float = 0.05  # 5% royalty
    minimum_royalty: float = 0  # Minimum annual payment
    per_unit_royalty: float = 0  # For per-unit structure
    royalty_tiers: List[RoyaltyTier] = field(default_factory=list)

    # Upfront payments
    upfront_fee: float = 0
    signing_bonus: float = 0
    milestone_payments: List[Dict[str, float]] = field(default_factory=list)

    # Licensee projections
    licensee_base_revenue: float = 0  # Current revenue from IP products
    licensee_revenue_growth: float = 0.10  # Expected growth rate
    licensee_units_base: float = 0  # For per-unit royalties
    licensee_unit_growth: float = 0.08

    # Market data
    industry_avg_royalty_rate: float = 0.05
    comparable_transactions: List[Dict[str, Any]] = field(default_factory=list)

    # Valuation inputs
    discount_rate: float = 0.12
    terminal_growth_rate: float = 0.02
    tax_rate: float = 0.25

    # Costs
    enforcement_costs: float = 0  # Legal/enforcement annual costs
    maintenance_costs: float = 0  # Patent maintenance, etc.

    # Analysis period
    projection_years: int = 10


class IPLicensingModel(BaseFinancialModel):
    """IP licensing transaction analysis model."""

    def __init__(self, model_id: str, name: str):
        super().__init__(model_id, name)
        self.inputs: Optional[IPLicensingInputs] = None

    def set_inputs(self, inputs: IPLicensingInputs) -> None:
        """Set model inputs."""
        self.inputs = inputs

    def validate_inputs(self) -> tuple[bool, List[str]]:
        """Validate model inputs."""
        errors = []

        if not self.inputs:
            errors.append("No inputs provided")
            return (False, errors)

        if self.inputs.royalty_rate <= 0 and self.inputs.per_unit_royalty <= 0 and self.inputs.upfront_fee <= 0:
            errors.append("Royalty rate, per-unit royalty, or upfront fee required")

        if self.inputs.license_term_years <= 0:
            errors.append("License term must be positive")

        if self.inputs.discount_rate <= 0:
            errors.append("Discount rate must be positive")

        return (len(errors) == 0, errors)

    def get_key_outputs(self) -> Dict[str, Any]:
        """Get the key output metrics for IP licensing analysis."""
        if not self.outputs:
            return {}
        return {
            "total_license_value": self.outputs.get("valuation", {}).get("total_license_value", 0),
            "npv_royalties": self.outputs.get("valuation", {}).get("npv_royalties", 0),
            "effective_royalty_rate": self.outputs.get("royalty_analysis", {}).get("effective_rate", 0),
            "total_royalty_income": self.outputs.get("royalty_analysis", {}).get("total_royalty_income", 0),
            "implied_ip_value": self.outputs.get("valuation", {}).get("implied_ip_value", 0),
        }

    def calculate(self) -> CalculationResult:
        """Run the IP licensing analysis."""
        is_valid, errors = self.validate_inputs()
        if not is_valid:
            return CalculationResult(success=False, errors=errors, outputs={})

        try:
            outputs = self._calculate_licensing()
            self.outputs = outputs
            return CalculationResult(success=True, errors=[], outputs=outputs)
        except Exception as e:
            return CalculationResult(success=False, errors=[str(e)], outputs={})

    def _calculate_licensing(self) -> Dict[str, Any]:
        """Calculate all IP licensing metrics."""
        inputs = self.inputs

        # IP asset summary
        ip_summary = self._calculate_ip_summary()

        # Royalty projections
        royalty_analysis = self._calculate_royalty_projections()

        # Upfront and milestone payments
        payments = self._calculate_payment_analysis()

        # Valuation
        valuation = self._calculate_valuation(royalty_analysis, payments)

        # Comparable analysis
        comparables = self._calculate_comparable_analysis()

        # Tax impact
        tax_analysis = self._calculate_tax_impact(royalty_analysis, payments)

        # Risk analysis
        risk = self._calculate_risk_analysis()

        return {
            "license_summary": {
                "ip_type": inputs.ip_type.value,
                "ip_name": inputs.ip_name or (inputs.ip_assets[0].name if inputs.ip_assets else ""),
                "license_type": inputs.license_type.value,
                "license_term_years": inputs.license_term_years,
                "territory": inputs.territory,
                "royalty_structure": inputs.royalty_structure.value,
            },
            "ip_summary": ip_summary,
            "royalty_analysis": royalty_analysis,
            "payment_analysis": payments,
            "valuation": valuation,
            "comparable_analysis": comparables,
            "tax_analysis": tax_analysis,
            "risk_analysis": risk,
            "years": list(range(1, inputs.projection_years + 1)),
        }

    def _calculate_ip_summary(self) -> Dict[str, Any]:
        """Summarize IP assets being licensed."""
        inputs = self.inputs

        if inputs.ip_assets:
            total_book = sum(a.book_value for a in inputs.ip_assets)
            total_comparable = sum(a.market_comparable_value for a in inputs.ip_assets)
            total_revenue = sum(a.current_annual_revenue for a in inputs.ip_assets)
            avg_life = sum(a.remaining_life_years for a in inputs.ip_assets) / len(inputs.ip_assets)

            assets_summary = [
                {
                    "name": a.name,
                    "type": a.ip_type.value,
                    "remaining_life": a.remaining_life_years,
                    "annual_revenue": a.current_annual_revenue,
                    "book_value": a.book_value,
                    "market_value": a.market_comparable_value,
                }
                for a in inputs.ip_assets
            ]
        else:
            total_book = 0
            total_comparable = 0
            total_revenue = inputs.licensee_base_revenue
            avg_life = inputs.remaining_life_years
            assets_summary = []

        return {
            "asset_count": len(inputs.ip_assets),
            "assets": assets_summary,
            "total_book_value": total_book,
            "total_comparable_value": total_comparable,
            "total_annual_revenue": total_revenue,
            "average_remaining_life": avg_life,
        }

    def _calculate_royalty_projections(self) -> Dict[str, Any]:
        """Project royalty income over license term."""
        inputs = self.inputs
        years = min(inputs.license_term_years, inputs.projection_years)

        annual_royalties = []
        cumulative = 0

        base_revenue = inputs.licensee_base_revenue
        base_units = inputs.licensee_units_base

        for year in range(1, years + 1):
            # Project licensee revenue/units
            if inputs.royalty_structure in [RoyaltyStructure.PERCENT_OF_SALES, RoyaltyStructure.PERCENT_OF_PROFITS]:
                revenue = base_revenue * ((1 + inputs.licensee_revenue_growth) ** year)
                royalty = self._calculate_royalty_for_revenue(revenue)
            elif inputs.royalty_structure == RoyaltyStructure.PER_UNIT:
                units = base_units * ((1 + inputs.licensee_unit_growth) ** year)
                royalty = units * inputs.per_unit_royalty
            elif inputs.royalty_structure == RoyaltyStructure.FLAT_FEE:
                royalty = inputs.minimum_royalty
            else:
                revenue = base_revenue * ((1 + inputs.licensee_revenue_growth) ** year)
                royalty = self._calculate_royalty_for_revenue(revenue)

            # Apply minimum royalty
            royalty = max(royalty, inputs.minimum_royalty)

            # Net of costs
            net_royalty = royalty - inputs.enforcement_costs - inputs.maintenance_costs

            annual_royalties.append({
                "year": year,
                "gross_royalty": royalty,
                "costs": inputs.enforcement_costs + inputs.maintenance_costs,
                "net_royalty": net_royalty,
            })

            cumulative += net_royalty

        # Calculate effective rate
        total_licensee_revenue = sum(
            base_revenue * ((1 + inputs.licensee_revenue_growth) ** y)
            for y in range(1, years + 1)
        )
        total_royalty = sum(r["gross_royalty"] for r in annual_royalties)
        effective_rate = total_royalty / total_licensee_revenue if total_licensee_revenue > 0 else 0

        return {
            "annual_royalties": annual_royalties,
            "total_royalty_income": total_royalty,
            "total_net_income": cumulative,
            "effective_rate": effective_rate,
            "average_annual_royalty": total_royalty / years if years > 0 else 0,
            "royalty_cagr": (annual_royalties[-1]["gross_royalty"] / annual_royalties[0]["gross_royalty"]) ** (1 / years) - 1 if years > 1 and annual_royalties[0]["gross_royalty"] > 0 else 0,
        }

    def _calculate_royalty_for_revenue(self, revenue: float) -> float:
        """Calculate royalty based on revenue and structure."""
        inputs = self.inputs

        if inputs.royalty_structure == RoyaltyStructure.TIERED and inputs.royalty_tiers:
            # Tiered calculation
            royalty = 0
            remaining_revenue = revenue
            prev_threshold = 0

            sorted_tiers = sorted(inputs.royalty_tiers, key=lambda t: t.threshold)

            for tier in sorted_tiers:
                tier_revenue = min(remaining_revenue, tier.threshold - prev_threshold)
                royalty += tier_revenue * tier.rate
                remaining_revenue -= tier_revenue
                prev_threshold = tier.threshold

                if remaining_revenue <= 0:
                    break

            # Revenue above highest tier
            if remaining_revenue > 0 and sorted_tiers:
                royalty += remaining_revenue * sorted_tiers[-1].rate

            return royalty
        else:
            return revenue * inputs.royalty_rate

    def _calculate_payment_analysis(self) -> Dict[str, Any]:
        """Analyze upfront and milestone payments."""
        inputs = self.inputs

        total_upfront = inputs.upfront_fee + inputs.signing_bonus

        milestone_total = sum(m.get("amount", 0) for m in inputs.milestone_payments)

        milestones = [
            {
                "name": m.get("name", f"Milestone {i+1}"),
                "amount": m.get("amount", 0),
                "year": m.get("year", i + 1),
                "probability": m.get("probability", 1.0),
                "expected_value": m.get("amount", 0) * m.get("probability", 1.0),
            }
            for i, m in enumerate(inputs.milestone_payments)
        ]

        expected_milestone_value = sum(m["expected_value"] for m in milestones)

        return {
            "upfront_fee": inputs.upfront_fee,
            "signing_bonus": inputs.signing_bonus,
            "total_upfront": total_upfront,
            "milestones": milestones,
            "total_milestones": milestone_total,
            "expected_milestone_value": expected_milestone_value,
            "total_guaranteed": total_upfront + inputs.minimum_royalty * inputs.license_term_years,
        }

    def _calculate_valuation(self, royalty_analysis: Dict[str, Any], payments: Dict[str, Any]) -> Dict[str, Any]:
        """Calculate license and IP valuation."""
        inputs = self.inputs

        discount_rate = inputs.discount_rate

        # NPV of royalties
        royalties = royalty_analysis["annual_royalties"]
        npv_royalties = sum(
            r["net_royalty"] / ((1 + discount_rate) ** r["year"])
            for r in royalties
        )

        # NPV of milestone payments
        npv_milestones = sum(
            m["expected_value"] / ((1 + discount_rate) ** m["year"])
            for m in payments["milestones"]
        )

        # Total license value
        total_license_value = payments["total_upfront"] + npv_royalties + npv_milestones

        # Terminal value (for perpetual or long-term licenses)
        if inputs.license_term_years >= 10:
            final_royalty = royalties[-1]["net_royalty"] if royalties else 0
            terminal_value = final_royalty * (1 + inputs.terminal_growth_rate) / (discount_rate - inputs.terminal_growth_rate)
            terminal_value_pv = terminal_value / ((1 + discount_rate) ** len(royalties))
        else:
            terminal_value = 0
            terminal_value_pv = 0

        # Implied IP value using relief from royalty method
        if inputs.royalty_rate > 0:
            implied_ip_value = npv_royalties / inputs.royalty_rate
        else:
            implied_ip_value = total_license_value

        # Value per remaining year
        value_per_year = total_license_value / inputs.license_term_years if inputs.license_term_years > 0 else 0

        return {
            "npv_royalties": npv_royalties,
            "npv_milestones": npv_milestones,
            "upfront_value": payments["total_upfront"],
            "total_license_value": total_license_value,
            "terminal_value": terminal_value,
            "terminal_value_pv": terminal_value_pv,
            "total_value_with_terminal": total_license_value + terminal_value_pv,
            "implied_ip_value": implied_ip_value,
            "value_per_year": value_per_year,
            "discount_rate": discount_rate,
        }

    def _calculate_comparable_analysis(self) -> Dict[str, Any]:
        """Analyze comparable transactions."""
        inputs = self.inputs

        if not inputs.comparable_transactions:
            return {
                "comparables": [],
                "median_royalty_rate": inputs.industry_avg_royalty_rate,
                "rate_vs_median": 0,
                "implied_value_from_comps": 0,
            }

        rates = [c.get("royalty_rate", 0) for c in inputs.comparable_transactions if c.get("royalty_rate", 0) > 0]
        values = [c.get("deal_value", 0) for c in inputs.comparable_transactions if c.get("deal_value", 0) > 0]

        median_rate = sorted(rates)[len(rates) // 2] if rates else inputs.industry_avg_royalty_rate
        median_value = sorted(values)[len(values) // 2] if values else 0

        rate_difference = inputs.royalty_rate - median_rate

        comparables = [
            {
                "name": c.get("name", f"Comp {i+1}"),
                "ip_type": c.get("ip_type", ""),
                "royalty_rate": c.get("royalty_rate", 0),
                "deal_value": c.get("deal_value", 0),
                "license_type": c.get("license_type", ""),
            }
            for i, c in enumerate(inputs.comparable_transactions)
        ]

        return {
            "comparables": comparables,
            "median_royalty_rate": median_rate,
            "average_royalty_rate": sum(rates) / len(rates) if rates else 0,
            "rate_vs_median": rate_difference,
            "rate_percentile": sum(1 for r in rates if r <= inputs.royalty_rate) / len(rates) if rates else 0.5,
            "median_deal_value": median_value,
            "industry_avg_rate": inputs.industry_avg_royalty_rate,
        }

    def _calculate_tax_impact(self, royalty_analysis: Dict[str, Any], payments: Dict[str, Any]) -> Dict[str, Any]:
        """Calculate tax impact of licensing arrangement."""
        inputs = self.inputs

        # Licensor tax on royalty income
        total_royalty = royalty_analysis["total_royalty_income"]
        royalty_tax = total_royalty * inputs.tax_rate

        # Tax on upfront
        upfront_tax = payments["total_upfront"] * inputs.tax_rate

        # Net after-tax income
        after_tax_royalty = total_royalty * (1 - inputs.tax_rate)
        after_tax_upfront = payments["total_upfront"] * (1 - inputs.tax_rate)

        # Licensee tax benefit (deduction for royalty payments)
        licensee_tax_benefit = total_royalty * inputs.tax_rate

        return {
            "licensor_royalty_tax": royalty_tax,
            "licensor_upfront_tax": upfront_tax,
            "licensor_total_tax": royalty_tax + upfront_tax,
            "after_tax_royalty_income": after_tax_royalty,
            "after_tax_upfront": after_tax_upfront,
            "total_after_tax_income": after_tax_royalty + after_tax_upfront,
            "licensee_tax_benefit": licensee_tax_benefit,
            "effective_cost_to_licensee": total_royalty - licensee_tax_benefit,
        }

    def _calculate_risk_analysis(self) -> Dict[str, Any]:
        """Analyze risks in licensing arrangement."""
        inputs = self.inputs

        # License type risk factor
        type_risk = {
            LicenseType.EXCLUSIVE: 0.8,  # Higher commitment, lower default risk
            LicenseType.NON_EXCLUSIVE: 1.0,
            LicenseType.SOLE: 0.9,
            LicenseType.FIELD_OF_USE: 1.1,
            LicenseType.TERRITORY: 1.1,
        }

        # IP type risk
        ip_risk = {
            IPType.PATENT: 1.0,
            IPType.TRADEMARK: 0.9,
            IPType.COPYRIGHT: 0.95,
            IPType.TRADE_SECRET: 1.3,
            IPType.TECHNOLOGY: 1.1,
            IPType.BRAND: 0.85,
            IPType.SOFTWARE: 1.15,
            IPType.CONTENT: 1.0,
        }

        base_risk = type_risk.get(inputs.license_type, 1.0) * ip_risk.get(inputs.ip_type, 1.0)

        # Concentration risk (single licensee)
        concentration_risk = "high" if inputs.license_type == LicenseType.EXCLUSIVE else "low"

        # Term risk
        term_risk = "low" if inputs.license_term_years <= 5 else ("medium" if inputs.license_term_years <= 10 else "high")

        # Minimum royalty coverage
        min_coverage = inputs.minimum_royalty / (inputs.licensee_base_revenue * inputs.royalty_rate) if inputs.licensee_base_revenue * inputs.royalty_rate > 0 else 0

        return {
            "base_risk_factor": base_risk,
            "concentration_risk": concentration_risk,
            "term_risk": term_risk,
            "minimum_royalty_coverage": min_coverage,
            "has_minimum_protection": inputs.minimum_royalty > 0,
            "remaining_ip_life_vs_term": inputs.remaining_life_years - inputs.license_term_years,
            "risk_adjusted_discount_rate": inputs.discount_rate * base_risk,
        }

    def run_sensitivity(
        self,
        variable: str,
        values: List[float],
        output_metric: str = "valuation.total_license_value"
    ) -> Dict[str, List[float]]:
        """Run sensitivity analysis on a variable."""
        results = []
        original_value = getattr(self.inputs, variable, None)

        for value in values:
            setattr(self.inputs, variable, value)
            result = self.calculate()

            if result.success:
                metric_value = self._get_nested_value(result.outputs, output_metric)
                results.append(metric_value)
            else:
                results.append(None)

        if original_value is not None:
            setattr(self.inputs, variable, original_value)

        return {
            "variable": variable,
            "values": values,
            "results": results,
            "metric": output_metric,
        }

    def _get_nested_value(self, data: Dict, path: str) -> Any:
        """Get a value from nested dictionary using dot notation."""
        keys = path.split(".")
        value = data
        for key in keys:
            if isinstance(value, dict):
                value = value.get(key)
            else:
                return None
        return value
